package org.tbk.bitcoin.regtest.config;

import lombok.AllArgsConstructor;
import lombok.Getter;
import org.springframework.boot.context.properties.bind.ConstructorBinding;
import org.springframework.validation.Errors;
import org.springframework.validation.Validator;

import java.time.Duration;
import java.util.Objects;
import java.util.Optional;

@Getter
@AllArgsConstructor(onConstructor = @__(@ConstructorBinding))
public class BitcoinRegtestMiningProperties implements Validator {
    /**
     * Whether mining should be enabled.
     */
    private boolean enabled;

    /**
     * Optional. A static address that all coinbase rewards will go to.
     * If not specified, a new address will be generated by the bitcoin client.
     */
    private String coinbaseRewardAddress;

    private int mineInitialAmountOfBlocks;

    private Boolean scheduledMiningEnabled;

    private NextBlockDurationProperties nextBlockDuration;

    public Optional<String> getCoinbaseRewardAddress() {
        return Optional.ofNullable(coinbaseRewardAddress);
    }

    public NextBlockDurationProperties getNextBlockDuration() {
        return nextBlockDuration != null ? nextBlockDuration : new NextBlockDurationProperties(null, null);
    }

    @Override
    public boolean supports(Class<?> clazz) {
        return clazz == BitcoinRegtestMiningProperties.class;
    }

    @Override
    public void validate(Object target, Errors errors) {
        BitcoinRegtestMiningProperties properties = (BitcoinRegtestMiningProperties) target;

        if (properties.getMineInitialAmountOfBlocks() < 0) {
            String errorMessage = String.format("'mineInitialAmountOfBlocks' must not be less than zero - invalid value: %d", properties.getMineInitialAmountOfBlocks());
            errors.rejectValue("mineInitialAmountOfBlocks", "mineInitialAmountOfBlocks.invalid", errorMessage);
        }
    }

    @Getter
    @AllArgsConstructor(onConstructor = @__(@ConstructorBinding))
    public static class NextBlockDurationProperties {
        private static final Duration DEFAULT_MIN_DURATION = Duration.ofSeconds(1);
        private static final Duration DEFAULT_MAX_DURATION = Duration.ofSeconds(60);

        private Duration minDuration;
        private Duration maxDuration;

        public Duration getMinDuration() {
            return Objects.requireNonNullElse(minDuration, DEFAULT_MIN_DURATION);
        }

        public Duration getMaxDuration() {
            Duration min = getMinDuration();

            return Optional.ofNullable(maxDuration)
                    .filter(val -> val.compareTo(min) >= 0)
                    .orElseGet(() -> max(min, DEFAULT_MAX_DURATION));
        }

        private static Duration max(Duration a, Duration b) {
            return a.compareTo(b) > 0 ? a : b;
        }
    }
}
